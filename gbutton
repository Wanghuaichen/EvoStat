#!/usr/bin/xpce
:- use_module(library(time)).
:- use_module(library(pce)).
:- use_module(library(process)).
:- use_module(library(charsio)).
:- use_module(library(helpidx)).
:- use_module(library(lists)).
:- use_module(library(ctypes)).

:- use_module(library(time)).
:- use_module(library(process)).

:- dynamic tog/1.
:- dynamic ard/5.
:- dynamic errs/2.
:- multifile errs/2.

% This fact implies:
% 
% Send 'b' to a cellstat to get turbidity(T)
% Store T in turbidity term
% and

interrogation(cellstat,[t:temperature,b:turbidity]).
interrogation(lagoon, [t:temperature]).

interrogate(Type) :-
    component(_, Type, Object),
    interrogation(Type, Questions),
    member(Cmd:Functor, Questions),
    send(Object,converse,Cmd),
    get(Object,slot,reply,Reply),
    catch( atom_to_term(Reply,Term,_Bind),
	   Exception,
	   writeln(expected(Functor/1,Reply,Exception))),
    Term =.. [Functor,Answer],
    send(Object,slot, Functor, Answer),
    fail.
interrogate(_).

timeatom(Hours,M,S,TimeAtom) :-
 	(M > 9 -> M = Minutes ; concat_atom(['0',M],Minutes)),
 	(S > 9 -> S = Seconds ; concat_atom(['0',S],Seconds)),
	concat_atom([Hours,':',Minutes,':',Seconds],TimeAtom).
	
window_percent(WFraction,HFraction,W,H) :-
	screen(DW,DH, WW, WH, _Loc),
	W is integer(DW*WW*WFraction/10000),
	H is integer(DH*WH*HFraction/11000).

compatible(T1,T2) :-
	nonvar(T1),nonvar(T2),
        functor(T1,Name,Arity),functor(T2,Name,Arity).
compatible(T1,T2) :-
	nonvar(T2),functor(T2,Name,Arity),
	writeln(parse_error(expected(Name/Arity),got(T1))),
	fail.

parse_reply(Reply, Term, Default) :-
	catch( atom_to_term(Reply,TmpTerm,_TMBindings),
	       Exception,
	       ( writeln(caught(Exception,atom_to_term(Reply))), TmpTerm = exception(Exception))),
	( compatible(TmpTerm,Default)
	 -> Term = TmpTerm
	;   Term = Default
	).

getIPfromMAC(_,_) :- fail.

snapshot(Path, FileName) :-
	directory_files(Path,FileList),
	member(IFile,FileList),
	atom_codes(IFile,ICs),
	append("mypic",_,ICs),
	concat_atom([Path,IFile],FileName),
	!.
snapshot(Path, Filename) :-
	concat_atom([Path,'opencvlevel.jpg'], Filename).


% WGET will use alternate filenames so we update Image properly
% and are never caught reading a file that hasn't been fully written

toggle('mypic1.jpg','mypic2.jpg') :- tog(2), retract(tog(2)),assert(tog(1)).
toggle('mypic2.jpg', 'mypic1.jpg') :- tog(1), retract(tog(1)),assert(tog(2)).

wget( OtherFile,
      '/usr/bin/wget',
      ['-q', '-O',File,
      'http://192.168.2.117:88/cgi-bin/CGIProxy.fcgi?cmd=snapPicture2&usr=scrapsec&pwd=lakewould']):-
      toggle(File,OtherFile).

repeat(N) :-
             integer(N), % type check
             N>0,        % value check 
             repeat1(N).

repeat1(1) :- !,plog(repeatN_exhausted).
repeat1(_).
repeat1(N) :- M is N-1, repeat1(M).

:- ( current_prolog_flag(arch,'i386-win32')
     -> load_foreign_library(foreign(plblue))
     ;  load_foreign_library(plblue)
   ),
   writeln('plblue (BLUETOOTH) loaded').

:- pce_begin_class(snapshot, label).

variable(imageDirectory, name, get, "Current Image Path" ).
variable(imageFile,      name, get, "Current Image Filename" ).

initialise(Self, Label:[name]) :->
	  "Initialise the image area"::
        send_super(Self, initialise(Label)),
        send_super(Self, alignment, center),
	snapshot('./',File),
	send(Self, slot, imageFile, File),
	send(Self, slot, imageDirectory, './'),
	new(I, image(File)),
	new(B, bitmap(I)),
	send(B, size, size(200,100)),
	send(Self, selection, B),
	assert(tog(1)).

shape(Self, W:[int], H:[int]) :->
	window_percent(W,H,MyWidth,MyHeight),
        writeln(size(Self,MyWidth,MyHeight)),
	send(Self, size, size(MyWidth,MyHeight)).

image(Self, File:[name])      :->
	send(Self,slot,imageFile, File).

imageDirectory(Self, Path:[name]) :-> send(Self,slot,imageDirectory, Path).

update(Self) :->
      writeln(updating(snapshot)),
      send(Self, selection, 'Refresh Image'),
      send(Self, flush),
      get(Self, imageDirectory, Path),
      snapshot(Path, NewFile),
      new(I, image(NewFile)),
      send(Self, slot, imageFile, NewFile),
      send(Self,selection, I),
      send(Self, flush),
      writeln(updated(snapshot)).

:- pce_end_class.


:- pce_begin_class(ebutton, button).

variable(myname,     name, get, "Component ID").
variable(socket,      any, get, "Bluetooth/IP Socket"      ).
variable(mac,        name, get, "Bluetooth/IP MAC Address" ).
variable(reply,      name, get, "Last Message from Device" ).
variable(level,        int, get, "Percent Full").
variable(level_t,      int, get, "Target Level").
variable(levelUnits, name, get, "% or mL (usually)"        ).

% Current Settings
variable(turbidity,    int, get, "Optical Density (600nM)").
variable(temperature,  int, get, "Temperature").

% Target Settings
variable(tturbidity,   int, get, "Target Optical Density (600nM)").
variable(ttemperature, int, get, "Target Temperature").

initialise(Self, Label:[name]) :->
	"Initialise the button and connect to device"::
        send_super(Self, initialise(Label)),
	send(Self, slot, myname, Label),
	send(Self, slot, levelUnits, 'mL'),
	send(Self, slot, ttemperature, 370),
	send(Self, slot, tturbidity, 400),
	send(Self, slot, temperature, 370),
	send(Self, slot, turbidity, 100),
	send(Self, slot, socket, @nil),
	( bt_device(Label,Mac),
	  send(Self, slot, mac, Mac),
	  send(Self, connect)
	; true
	),
	new(Code2, message(Self, show_conversation)),
	send(Self, recogniser, click_gesture(right,'',single,Code2)).

% Indicate a live Bluetooth connection with green
update(Self) :->
	( get(Self, slot, socket, @nil)
	-> send(Self,colour,colour(red))
	;  send(Self,colour,colour(darkgreen))
	).
	
show_conversation(Self) :->
        Self = @Name,
        get(Self, socket, Socket),
	new(_, dialin(Name,Socket)).
	
targetLevel(Self, Level) :->
       send(Self, slot, level_t, Level),
       get(Self, slot, myname, Name),
       retract(webok),
       retractall(param(Name,_,level_t,_)),
       assert(param(Name,_,level_t,Level)),
       assert(webok).

level(@Name, Level) :->
       send(@Name, slot, level, Level),
       retract(webok),
       retractall(param(Name,_,level,_)),
       assert(param(Name,_,level,Level)),
       assert(webok).

levelUnits(@Name, Units) :->
       send(@Name, slot, levelUnits, Units),
       retract(webok),
       retractall(param(Name,_,levelUnits,_)),
       assert(param(Name,_,levelUnits,Units)),
       assert(webok).

mix_colors(   C,   C,      C) :- !.
mix_colors(   _,blue, purple) :- !.
mix_colors(blue,   _, purple) :- !.
mix_colors(green,  _, orange) :- !.
mix_colors( _, green, orange) :- !.
mix_colors( _, red,   red).

compute(_) :-> true.

% Shape is defined as a percentage of the screen
shape(Self, W:[int], H:[int]) :->
	window_percent(W,H,MyWidth,MyHeight),
%	writeln(shape(Self,MyWidth,MyHeight)),
	send(Self, size, size(MyWidth,MyHeight)).

od(Self, OD600:[real]) :->
	 Turb is integer(OD600*1000),
	 send(Self, slot, tturbidity, Turb).

temp(Self, Temp:[int]) :->
	 send(Self, slot, ttemperature, Temp),
         plog(tempsetting(Self,Temp)).

% Cellstat, Lagoon, and Autosampler Bluetooth Communications
%
% Wedged Arduinos give null responses, but just what constitutes
% a null response when there are SIX kinds of nutthin!
%
nullreply("") :- !,writeln(reply(doublequotes)).
nullreply([]) :- !,writeln(reply(emptylist)).
nullreply(['']) :- !,writeln(reply(emptyatominalist)).
nullreply('') :- !,writeln(reply(emptyatom)).
nullreply(``) :- !,writeln(reply(emptystring)).
nullreply(AS) :- atom_string('',AS),!,writeq(reply(atomstring)).
nullreply(NR) :- !,writeq(reply(good,NR)),fail.

converse(Self, Cmd) :->
	"Send command to Bluetooth Socket and save Reply ( Cellstat/Lagoon )"::
        get(Self, socket, Socket),
	bluetalk(Socket, Cmd, Reply),
	( nullreply(Reply)
	 ->  get_super(Self, slot, myname, MyName),
	     bt_areset(Socket),
	     count(reset, MyName),
	     sleep(4),
	     bluetalk(Socket, Cmd, Reply2),
	     ( nullreply(Reply2)
	      -> assert(err(MyName, new_socket)),
		 send(Self, connect),
		 bluetalk(Socket, Cmd, Reply3),
		 ( nullreply(Reply3)
		  -> assert(err(MyName,and(reset,new_socket))),
		     send(Self, slot, reply, 'failure.')
		  ; send(Self, slot, reply, Reply3)
		 )
	      ; send(Self, slot, reply, Reply2)
	     )
	 ; send(Self, slot, reply, Reply)
	).

connect(Self) :->
	"Connect (or re-connect) the Bluetooth channel"::
	get(Self, mac, Addr),
	get(Self, socket, OldSocket),
        ( OldSocket == @nil -> true
	; bt_close(OldSocket),
	  send(Self, slot, socket, @nil)
	),
	( bt_socket(Addr, BTSocket) ->
	  write(socket(BTSocket)),write(' '),
	  ( BTSocket > -1 ->
	    send(Self, slot, socket, BTSocket),
	    send(Self,colour,colour(darkgreen))
	    ; send(Self,colour,colour(red))
	  )
	  ; write(failed(bt_socket)),
	    send(Self,colour,colour(red))
	).

insertIP(Cmd, IP, Result) :-
        atom_codes(Cmd, Cs),
        atom_codes(IP, ICs),
	[AT] = "@",
        append(Front,[AT|Rest],Cs),
	flatten([Front,ICs,Rest],CommandCs),
	atom_codes(Result,CommandCs).

ip(Self, IP:[name]) :->
	 socket(IP, Socket),
	 send(Self, slot, ipsocket, Socket).

mac_wget(Self, MAC:[name], Cmd:[name]) :->
        getIPfromMAC(MAC,IP),
	send(Self, wget, wget(IP, Cmd)).

wget(Self, IP:[name], Cmd:[name]) :->
        insertIP(Cmd,IP,Command),
	send(Self, slot, wget, Command).

mac(Self, MAC:[name]) :->
        getIPfromMAC(MAC,IP),
	send(Self, ip, ip(IP)).

:- pce_end_class. % ebutton

:- pce_begin_class(cellstat, ebutton).

variable(leak,   int, get, "Leak Detector").

initialise(Self, Label:[name]) :->
	"Initialise the cellstat"::
        send_super(Self, initialise(Label)),
	send_super(Self, slot, level, 85),
	send_super(Self, slot, level_t, 85),
	send_super(Self, slot, levelUnits, '%'),
	get_super(Self, slot, ttemperature, Target),
	get_super(Self, slot, temperature, Temp),
	get_super(Self, slot, tturbidity, ODTarget),
	get_super(Self, slot, turbidity, Turb),

% Default values: Web Interface must work before any updates
        retractall(param(Label,cellstat,_,_)),
	assert(param(Label,cellstat,level,85)),
	assert(param(Label,cellstat,level_t,85)),
	assert(param(Label,cellstat,levelUnits,'%')),
	assert(param(Label,cellstat,ttemperature,Target)),
	assert(param(Label,cellstat,temperature,Temp)),
	assert(param(Label,cellstat,tturbidity,ODTarget)),
	assert(param(Label,cellstat,turbidity,Turb)),
	writeln(cellstat(asserted)).

check_leak(leak(N)) :- !, check_leak_value(N).
check_leak(P)       :-    writeln(expected(leak/1,P)).


check_leak_value(N) :-  N > 700,
			!,
			writeln('No leak'),
			retractall(leak(_)),
			send(@gui?graphicals, for_all,
			     if(message(@arg1,instance_of,spacer),
				message(@arg1,resetColor))).
			

check_leak_value(N) :- N < 300,
		       !,
		       writeln(leak(definitely)),
		       retractall(leak(_)),
		       assert(leak(definite)),
		       send(@gui?graphicals, for_all,
			    if(message(@arg1,instance_of,spacer),
			       message(@arg1,color,red))).

check_leak_value(N) :- writeln(leak(possible,N)),
		       retractall(leak(_)),
		       assert(leak(possible)),
		       send(@gui?graphicals, for_all,
			    if( message(@arg1,instance_of,spacer),
				message(@arg1,color,orange))).

reportDeltaT(Who, Old, New) :-
	DeltaT is integer(abs(Old-New)/10), % DeltaT in degrees
	retractall(err(Who,deltaT(_))),
	(DeltaT > 5 -> assert(err(Who,deltaT(DeltaT))) ; true).

reportTemp(Who,Target,Temp) :-  % Temperatures are 10th degrees
	LowThresh is Target - 20, % +- 2 degrees
	HighThresh is Target + 20,
	retractall(temperature(Who,_,_)),
	( Temp < LowThresh -> assert(temperature(Who,low,Temp))
	; ( Temp > HighThresh -> assert(temperature(Who,high,Temp))
	  ; assert(temperature(Who,okay,Temp))
	  )
	).

update(Self) :->
	get_super(Self, slot, myname, MyName),
	writeln(updating(MyName)),
	send_super(Self, update),
	send_super(Self,converse,'t'),
        get(Self,slot,reply,Reply),
	(Reply='no_connection.'
	-> concat_atom([MyName,'\nNo Bluetooth\nConnection'],Label)
	;
% TEMPERATURE	
	parse_reply(Reply, temperature(Temp), temperature(111)),
	get(Self, slot, temperature, PreviousTemp),
	reportDeltaT(MyName, PreviousTemp, Temp),
        send(Self,slot, temperature, Temp),
        get(Self, slot, ttemperature, Target),
	reportTemp(MyName,Target,Temp),
	writeln(update(cellstat,aftertemp)),
	range_color(Target, Temp, Tc),
        get(Self, slot, tturbidity, ODTarget),
% LEAK
	send_super(Self,converse,'w'),
        get(Self, slot, reply, LeakReply),
	parse_reply(LeakReply,Leak,leak(666)),
	check_leak(Leak),
% TURBIDITY
	send_super(Self,converse,'b'),
        get(Self, slot, reply, TurbReply),
        atom_to_term(TurbReply,TbTerm,_TBBindings),
	TbTerm = turbidity(TurbVal),
	send(Self, slot, turbidity, TurbVal),
	range_color(ODTarget, TurbVal, ODc),
	mix_colors(Tc,ODc,Color),
	send(Self, colour(Color)),

	get(Self, slot, level, Level),
	get(Self, slot, level_t, TLevel),
	get(Self, slot, levelUnits, LevelUnits),

        writeq(user_error, arithmetic(Temp)),
	TempF is float(Temp)/10.0,
	TargetF is float(Target)/10.0,
	limit(TurbVal, 0, 999, TurbL),
	format(atom(TempFmt), '~4g', [TempF]),
	format(atom(TargFmt), '~4g', [TargetF]),
        concat_atom(['\n',MyName,'  ',TLevel,' / ', Level, LevelUnits, '\nTemperature: ', TargFmt, ' / ',TempFmt,'\n',
 		'Turbidity:  0.', ODTarget,' / 0.', TurbL, '\n'], Label)
	), % Else for 'no connection'
	send(Self, label, Label),

        repeat(20),sleep(0.1),retract(webok), % SEMAPHORE
	NewValues = [
	param(MyName,cellstat,level,Level),
	param(MyName,cellstat,level_t,TLevel),
	param(MyName,cellstat,levelUnits,LevelUnits),
	param(MyName,cellstat,ttemperature,Target),
	param(MyName,cellstat,temperature,Temp),
	param(MyName,cellstat,tturbidity,ODTarget),
	param(MyName,cellstat,turbidity,TurbL)],
	(ground(NewValues) ->
             retractall(param(MyName,cellstat,_,_)),
	     maplist(assert,NewValues),
             write(user_error,updated(cellstat,level(Level))),nl(user_error)
	 ;   write(user_error,failed_update(MyName)),nl(user_error)
	),
        assert(webok).

:- pce_end_class.  % cellstat

:- pce_begin_class(lagoon, ebutton).

variable(fluorescence,real, get, "Fluorescence").
variable(fluorescence_t, real, get, "Target Fluorescence").
variable(level_max, real, get, "Max Allowed Level").
variable(calibrate_level, real, get, "Calibration Level").

variable(calibration, name, get, "Calibration State Machine").
variable(target_rate, real, get, "Target Flow Rate").
variable(start_time, real, get, "Time since last Calibration state change").
variable(rate_input, real, get, "Calculated Input Flow Rate").
variable(rate_output, real, get, "Calculated Output Flow Rate").
variable(calibration, name, get, "Calibration State Machine").
variable(overflow,   int,   get, "Indication of Overflow").

initialise(Self, Label:[name]) :->
	"Initialise the lagoon"::
        send_super(Self, initialise(Label)),
	send(Self, slot, calibration, normal),
	send_super(Self, slot, level, 30),
	send_super(Self, slot, level_t, 33),
	send(Self, slot, fluorescence_t, 0.2),
	send(Self, slot, overflow, 0),
	send(Self, slot, fluorescence, 0.0),
	retractall(param(Label,lagoon,_,_)),
	assert(param(Label,lagoon,level,33)),
	assert(param(Label,lagoon,level_t,33)),
	assert(param(Label,lagoon,levelUnits,mL)),
	assert(param(Label,lagoon,ttemperature,370)),
	assert(param(Label,lagoon,levelUnits,mL)),
	assert(param(Label,lagoon,temperature,240)).


update(Self) :->
        get(Self, slot, myname, MyName),
	writeln(updating(lagoon(MyName))),
        send_super(Self, update),
        send_super(Self,converse,'t'),
        get(Self,slot,reply,Reply),
	(Reply = 'no_connection.'
	-> Label = 'No Bluetooth\nConnection'
	;
	parse_reply(Reply,temperature(Temp),temperature(111)),
        get(Self,slot,temperature,PreviousTemp),
	reportDeltaT(MyName, PreviousTemp, Temp),
        send(Self,slot,temperature,Temp),
        writeq(user_error, arithmetic2(Temp)),
	TempDeg is float(Temp)/10.0,
        get(Self,slot,ttemperature,Target),
	TargetDeg is float(Target)/10.0,
	LowThresh is Target - 2,
	HighThresh is Target + 2,
	retractall(temperature(lagoon,_,_)),
	( Temp < LowThresh -> assert(temperature(lagoon,low,Temp))
	; ( Temp > HighThresh -> assert(temperature(lagoon,high,Temp))
	  ; assert(temperature(lagoon,okay,Temp))
	  )
	),
	reportTemp(MyName,Target,Temp),
	range_color(Target, Temp, Color),
	send(Self, colour(Color)),
        get(Self, slot, level, Level),
        get(Self, slot, level_t, TLevel),
        get(Self, slot, levelUnits, LevelUnits),
        get(Self, slot, fluorescence_t,LuxTarget),
        get(Self, slot, fluorescence,Lux),
	format(atom(GuiTemp), '~4g', [TempDeg]),
	format(atom(GuiTarget), '~4g', [TargetDeg]),
	format(atom(Lux2), '~4g', [Lux]),
%	get(Self,slot,calibration,State),  % Calibration State is the Message
%	send(Self,State),
        concat_atom(['Level ', TLevel, ' / ', Level, LevelUnits, '\n',
	             'Temp  ', GuiTarget, 'C / ',GuiTemp,' C\n',
                     'Lux   ', LuxTarget, ' / ', Lux2, 'lumen' ], Label)
	),
	send(Self, label, Label),
        repeat(20),sleep(0.1),retract(webok), % SEMAPHORE
	NewValues = [
		     param(MyName,lagoon,level_t,TLevel),
		     param(MyName,lagoon,level,Level),
		     param(MyName,lagoon,levelUnits,LevelUnits),
		     param(MyName,lagoon,ttemperature,Target),
		     param(MyName,lagoon,temperature,Temp)],
	(ground(NewValues) ->
             retractall(param(MyName,lagoon,_,_)),
	     maplist(assert,NewValues),
             write(user_error,updated(MyName,level(Level))),nl(user_error)
	 ;   write(user_error,failed_update(MyName)),nl(user_error)
	),
        assert(webok).

control_level(Self) :->                         % Level within range
	get(Self,slot,level,Level),
	get(Self,slot,level_t,TargetLevel),
	get(Self,slot,level_max,MaxLevel),
	Level < MaxLevel,
	Level > TargetLevel-1,
	!.

control_level(Self) :->                        % Overfilling !
	get(Self,slot,level,Level),
	get(Self,slot,level_max,MaxLevel),
	Level > MaxLevel,
	!,
	( get(Self,slot,overflow,1) -> true   % Already draining,
	;  send_super(Self,converse,'a0'),    %   or start now 
	   send(Self, slot, overflow, 1)
	).

control_level(Self) :->
	get(Self,slot,level,Level),
	get(Self,slot,level_t,TargetLevel),
	Level < TargetLevel + 1,                % Level close to Normal
	( get(Self, slot, overflow, 1)          % If draining, go back to auto-on
	 -> send_super(Self, converse, 'a1'),
	    send(Self, slot, overflow, 0)
        ; true
	).

	
% Calibration begins after someone sends the 'calibrate' message
% Lagoons can distiguish between input valves and output valves.
% command: do (disable output valves)
%          eo (enable outputs)
%          di (disable input valves)
%          ei (enable input valves)

calibrate(Self) :->
    get(Self,slot,calibration,C),
    writeln(calibration(Self,C)),
    C = normal,
    send(Self,slot,calibration,inflow),
    get_time(Time),
    send(Self,slot,start_time,Time),
    get(Self,slot,level,Level),
    CLevel is 1.1 * Level,
    send(Self,slot,calibrate_level,CLevel).
%    send(Self,command, do).  % Disable Output Flow(s)


setFlux(Self,Level) :->
       send(Self, slot, fluorescence, Level).


normal(_Self) :-> true.

inflow(Self) :->
    get_time(Now),
    get(Self,slot,start_time,STime),
    Now >= STime + 20,
    !,
    writeln(calibrationInflowTimedOut(Self)),
    send(Self,slot,calibration,outflow),
    get(Self,slot,level,Level),
    get(Self,slot,calibrate_level,CLevel),
    Level >= CLevel,
    get_time(Time),
    get(Self,slot,start_time,StartTime),
    RateInput is ( Level/(10*(Time-StartTime))),
    send(Self,slot,rate_input,RateInput),
    CLevel is Level - (Level/11.0),
    get(Self,slot,calibrate_level,Level),
    get(Self,slot,start_time,Time), % Restart timer
%    send(Self,command, eo), % Enable Output Flow(s)
%    send(Self,command, di), % Disable Input Flow(s)
    send(Self,slot,calibration,outflow),
    !.
	       
% Calculate Output Flow Rate with time to decrease volume by 10% (1/11)

outflow(Self) :->
    get_time(Now),
    get(Self,slot,start_time,STime),
    Now >= STime + 20,
    !,
    writeln(calibrationOutflowTimedOut(Self)),
    send(Self,slot,calibration,normal),
    get(Self,slot,level,Level),
    get(Self,slot,calibrate_level,CLevel),
    Level =< CLevel,
    get_time(Time),
    get(Self,slot,start_time,StartTime),
    RateOutput is ( CLevel/(10*(Time-StartTime))),
    send(Self,slot,rate_output,RateOutput),
    send(Self,slot,calibration,normal),
%    send(Self, command, ei), % Re-enable Normal Input Flow(s)
    !.

% Adjust valve times with the calculated Flow Rates
done(Self) :->
    get(Self,slot,target_rate, TargetFlow),
    get(Self,slot,rate_input, RateInput),
    _DeltaInput is TargetFlow - RateInput,
%    send(Self,command,[ai,DeltaInput]),
    get(Self,slot,rate_output, RateOutput),
    _DeltaOutput is TargetFlow - RateOutput,
%    send(Self,command,[ao,DeltaOutput]),
    send(Self,slot,calibration,normal).

:- pce_end_class.  % lagoon


:- pce_begin_class(supply, ebutton).

% "Target Level" is used differently in a Supply.  Since we can't
% "maintain" a level in a supply container, but we can alert someone
% when it gets too low.  The Target Level is that level (of depletion).

initialise(Self, Label:[name]) :->
	"Initialise the autosampler"::
        send_super(Self, initialise(Label)),
	send(Self,slot,level,0),
	send(Self,slot,level_t,10),
	send(Self,slot,levelUnits,'L'),
        retractall(param(Label,supply,_,_)),
	assert(param(Label,supply,levelUnits,'L')),
	assert(param(Label,supply,level,0)).

update(Self) :->
	send_super(Self, update),
	get_super(Self, slot, myname, MyName),
	writeln(updating(MyName)),
	get(Self, slot, level, Level),
	get(Self, slot, levelUnits, Units),
	concat_atom([MyName,' \n',Level,Units],Label),
	send(Self, label, Label),
        retractall(webok),
	retractall(param(MyName,supply,_,_)),
	assert(param(MyName,supply,level,Level)),
	assert(param(MyName,supply,levelUnits,Units)),
        assert(webok),
	get(Self, slot, level_t, Target),
	(Level < Target
	 -> send(Self, colour, colour(red))
         ;  send(Self, colour, colour(black))
        ).
	
:- pce_end_class.  % supply

:- pce_begin_class(drainage, ebutton).
initialise(Self, Label:[name]) :->
	"Initialise the drain"::
        send_super(Self, initialise(Label)).

update(_Self) :-> true.
:- pce_end_class.  % drainage


:- pce_begin_class(sampler, ebutton).

variable(remaining,   int,   get, "Seconds until next Sample").
variable(flowrate,   real,   get, "Flow Rate in Volumes/Hour").

initialise(Self, Label:[name]) :->
	"Initialise the autosampler"::
        send_super(Self, initialise(Label)),
	assert(param(Label,sampler,flowrate,3.5)),
	send(Self, slot, flowrate, 3.5),
	send(Self, slot, myname, Label),
	send(Self,slot,remaining,3600).

update(Self) :->
	send_super(Self, update),
	( get_super(Self, socket, @nil) -> true
	; send_super(Self,converse,'t'),
	  get_super(Self, reply, Reply),
	  DefaultTime is 99*60, % 99 Minutes
	  parse_reply(Reply, Remaining, remaining(DefaultTime)),
	  Remaining = remaining(Time),
	  send(Self,slot,remaining,Time)
	),
	send(Self,fast_update).
	  
fast_update(Self) :->
	get_super(Self, slot, myname, MyName),
	get(Self,slot,remaining,Time),
	Hours is floor(Time/3600),
	Minutes is floor(mod(Time,3600)/60),
	Seconds is Time mod 60,
	timeatom(Hours,Minutes,Seconds,TimeAtom),
	timer_left(CTime),
	param(updateCycle(Cycle)),
	TimeLeft is Cycle-CTime,
	(TimeLeft < 0 -> ShowTime = Cycle ; ShowTime = TimeLeft),
	(ShowTime < 10
	-> concat_atom(['\nAutoSampler\n',
		      ' Level reading in Progress...\n',
		      TimeAtom,' to next sample\n'],Label)
	; concat_atom(['\nAutoSampler\n',
		      ShowTime,' seconds to level reading\n',
		      TimeAtom,' to next sample\n'],Label)
        ),
	send(Self, label, Label),
        repeat(20),sleep(0.1),retract(webok), % SEMAPHORE
	param(MyName,sampler,flowrate,FlowRate),
	NewValues = [param(MyName,sampler,flowrate,FlowRate),
		     param(MyName,sampler,timeleft,ShowTime),
		     param(MyName,sampler,nextsample,TimeAtom)],
	(ground(NewValues) ->
             retractall(param(MyName,sampler,_,_)),
	     maplist(assert,NewValues),
             write(user_error,updated(MyName,timeleft(ShowTime))),nl(user_error)
	 ;   write(user_error,failed_update(MyName)),nl(user_error)
	),
        assert(webok).

flow(Self, Rate:[real]) :-> 
	send(Self, slot, flowrate, Rate),
	get(Self,slot,myname, MyName),
	retractall(param(MyName,sampler,flowrate,_)),
	assert(param(MyName, sampler,flowrate,Rate)).

:- pce_end_class.  % autosampler


:- pce_begin_class(spacer, box).

variable(defaultColor, name, get, "DefaultColor" ).

initialise(Self, _Name:[name]) :->
        screen(DW,_,WW,_,_),
	NWid is DW*WW/110,
        send_super(Self, initialise(NWid, 6)),
	send(Self, colour, colour(black)),
	send(Self, slot, defaultColor, black),
	send(Self, fill_pattern, colour(black)).

color(Self, Color) :->
     ( get(Self,slot,defaultColor,colour(black))   % First time
      -> send(Self,slot,defaultColor,Color)  % New default
      ; true
     ),
     send(Self, colour, colour(Color)),
     send(Self, fill_pattern, colour(Color)).

resetColor(Self) :-> 
     get(Self,slot,defaultColor,C),
     send(Self, colour, colour(C)).

update(_Self) :-> true.

:- pce_end_class.

:- pce_begin_class(hotbox, box).
initialise(Self, Color:[name]) :->
        "Initialise"::
        window_percent(1,2,Width,Height),
        send_super(Self, initialise(Width,Height)),
	send(Self, colour, colour(black)),
        send(Self, fill_pattern, colour(Color)).
:- pce_end_class.
