#!/usr/bin/xpce
:- use_module(library(time)).
:- use_module(library(pce)).
:- use_module(library(process)).
:- use_module(library(charsio)).
:- use_module(library(helpidx)).
:- use_module(library(lists)).
:- use_module(library(ctypes)).

:- use_module(library(time)).
:- use_module(library(process)).

:- dynamic tog/1.
:- dynamic ard/5.
:- dynamic errs/2.
:- multifile errs/2.

filldigits(N,In,Out) :-
    number_codes(In,Chs),
    length(Chs,Len),
    (Len = N -> In = Out
    ; (Len is N-1 -> atom_codes(Out,[0'0|Chs])
      ; (Len is N-2 -> atom_codes(Out, [0'0,0'0|Chs]) ; true))).

timeatom(Hours,M,S,TimeAtom) :-
 	(M > 9 -> M = Minutes ; concat_atom(['0',M],Minutes)),
 	(S > 9 -> S = Seconds ; concat_atom(['0',S],Seconds)),
	concat_atom([Hours,':',Minutes,':',Seconds],TimeAtom).
	
window_percent(WFraction,HFraction,W,H) :-
	screen(DW,DH, WW, WH, _Loc),
	W is integer(DW*WW*WFraction/10000),
	H is integer(DH*WH*HFraction/11000).

mix_colors(   C,   C,      C) :- !.
mix_colors(   _,blue, purple) :- !.
mix_colors(blue,   _, purple) :- !.
mix_colors(green,  _, orange) :- !.
mix_colors( _, green, orange) :- !.
mix_colors( _, red,   red).

compatible(T1,T2) :-
	nonvar(T1),nonvar(T2),
        functor(T1,Name,Arity),functor(T2,Name,Arity).
compatible(T1,T2) :-
	nonvar(T2),functor(T2,Name,Arity),
	writeln(parse_error(expected(Name/Arity),got(T1))),
	fail.

% The Autosampler controls drain valves for the other components

% Return the component's drain valve
component_drain(Obj, Valve) :-
    component(Lagoon,lagoon,Obj),
    !,
    atom_codes(Lagoon, Codes),
    append(_,[Digit],Codes),
    atom_codes(Valve, [0'i,Digit]).

component_drain(_, i0).

adjust(Obj, Amt) :-
      Inflow is   Amt/2,
      Outflow is -Amt/2,
      adjust_valve(Obj,i1,Inflow),
      component_drain(Obj,Drain),
      component(_,sampler,S),
      adjust_valve(S,Drain,Outflow).

adjust_valve(Obj, Valve, Amt) :-
      get(Obj, Valve, Setting),
      New is Setting + Amt,
      send(Obj, Valve, New),
      assert(changed(Obj,Valve)).

parse_reply(Reply, Term, Default) :-
	catch( atom_to_term(Reply,TmpTerm,_TMBindings),
	       Exception,
	       ( writeln(caught(Exception,atom_to_term(Reply))), TmpTerm = exception(Exception))),
	( compatible(TmpTerm,Default)
	 -> Term = TmpTerm
	;   Term = Default
	).

getIPfromMAC(_,_) :- fail.

snapshot(Path, FileName) :-
	directory_files(Path,FileList),
	member(IFile,FileList),
	atom_codes(IFile,ICs),
	append("mypic",_,ICs),
	concat_atom([Path,IFile],FileName),
	!.
snapshot(Path, Filename) :-
	concat_atom([Path,'opencvlevel.jpg'], Filename).


% WGET will use alternate filenames so we update Image properly
% and are never caught reading a file that hasn't been fully written

toggle('mypic1.jpg','mypic2.jpg') :- tog(2), retract(tog(2)),assert(tog(1)).
toggle('mypic2.jpg', 'mypic1.jpg') :- tog(1), retract(tog(1)),assert(tog(2)).

wget( OtherFile,
      '/usr/bin/wget',
      ['-q', '-O',File,
      'http://192.168.2.117:88/cgi-bin/CGIProxy.fcgi?cmd=snapPicture2&usr=scrapsec&pwd=lakewould']):-
      toggle(File,OtherFile).

repeat(N) :-
             integer(N), % type check
             N>0,        % value check 
%	     write(user_error,repeat(N)), nl(user_error),
             repeatN(N).

repeatN(1) :- !,plog(repeatN_exhausted),fail.
repeatN(_).
repeatN(N) :- M is N-1, repeatN(M).

waitfor(N,Atom,_) :-
   repeat(N),
   ( call(Atom) -> true ; sleep(0.2), fail ),
   !.

waitfor(N,Atom,Who) :-  
    plog(failed(waitfor(N,Atom,Who))),
    fail.
    
semaphore(N,Atom,_) :- % wait for and grab it
   repeat(N),
   ( retract(Atom) -> true ; sleep(0.2), fail ),
   !.

semaphore(N,Atom,Who) :- % Report failure and assert a new one (dangerous?)
    plog(failed(semaphore(Who,N,Atom))),
    retractall(webok),  % In case we failed for another reason.
    assert(webok),
    plog(asserting(webok)),
    fail.

:- ( current_prolog_flag(arch,'i386-win32')
     -> load_foreign_library(foreign(plblue))
     ;  load_foreign_library(plblue)
   ),
   writeln('plblue (BLUETOOTH) loaded').

:- pce_begin_class(snapshot, window).

initialise(Self, Label:[name]) :->
	  "Initialise the image area"::
        send_super(Self, initialise(Label)),
        send_super(Self, alignment, center),
	send(Self, size, size(580,440)),
	new(I, image('./web/phagestat.jpg')),
	send(Self, display, new(_, bitmap(I))).

update(Self) :->
      writeln(updating(snapshot)),
      R is random(100),
      concat_atom(['./web/phagestat',R,'.jpg'],NewFile),
      copy_file('./web/phagestat.jpg',NewFile),
      send(Self, display, new(_, bitmap(NewFile))),
      delete_file(NewFile),
      write(user_error, updated(snapshot)), nl(user_error).

:- pce_end_class.

:- pce_begin_class(ebutton, button).

variable(myname,           name, both, "Component ID"             ).
variable(socket,            any, both, "Bluetooth/IP Socket"      ).
variable(reply,            name, both, "Last Message from Device" ).
variable(l,                 int, both, "Percent Full"             ).
variable(tl,                int, both, "Target Level"             ).
variable(levelUnits,       name, both, "% or mL (usually)"       ).
variable(turbidityUnits,   name, both, "Optical Density (600nM)" ).
variable(temperatureUnits, name, both, "C"                       ).
variable(fluxUnits,        name, both, "rlu"                     ).

initialise(Self, Label:[name]) :->
	"Initialise the button and connect to device"::
        send_super(Self, initialise(Label)),
        send(Self, myname, Label),
	send(Self, slot, l,  30),
	send(Self, slot, tl, 87),
	send(Self, slot, levelUnits,   'mL'),
	send(Self, slot, temperatureUnits,   'C'),
	send(Self, slot, turbidityUnits,   'OD(600)'),
	send(Self, slot, fluxUnits,        'rlu'),
	send(Self, slot, socket, @nil),
	send(Self, connect),
	new(Code,  message(Self, show_conversation)),
	send(Self, recogniser, click_gesture(right,'',single,Code)).

update(_Self) :-> true. % Anything that all buttons do
	
show_conversation(Self) :->
        Self = @Name,
        get(Self, socket, Socket),
	new(_, dialin(Name,Socket)).
	

targetLevel(Self, Level) :->
       send(Self, slot, level_t, Level),
       get(Self, slot, myname, Name),
       semaphore(4,webok,targetLevel),
       retractall(param(Name,_,level_t,_)),
       assert(param(Name,_,level_t,Level)),
       assert(webok).

compute(_) :-> true.

% Shape is defined as a percentage of the screen
shape(Self, W:[int], H:[int]) :->
	window_percent(W,H,MyWidth,MyHeight),
%	writeln(shape(Self,MyWidth,MyHeight)),
	send(Self, size, size(MyWidth,MyHeight)).

od(Self, OD600:[real]) :->
	 Turb is integer(OD600*1000),
	 send(Self, slot, tturbidity, Turb).

temp(Self, Temp:[int]) :->
	 send(Self, slot, ttemperature, Temp),
         plog(tempsetting(Self,Temp)).

% Cellstat, Lagoon, and Autosampler Bluetooth Communications
%
% Wedged Arduinos give null responses, but just what constitutes
% a null response when there are SIX kinds of nutthin!
%
nullreply("") :- !,writeln(reply(doublequotes)).
nullreply([]) :- !,writeln(reply(emptylist)).
nullreply(['']) :- !,writeln(reply(emptyatominalist)).
nullreply('') :- !,writeln(reply(emptyatom)).
nullreply(``) :- !,writeln(reply(emptystring)).
nullreply(AS) :- atom_string('',AS),!,writeq(reply(atomstring)).
%nullreply(NR) :- writeq(reply(good,NR)),fail.

converse(Self, Cmd) :->
	"Send command to Bluetooth Socket and save Reply ( Cellstat/Lagoon )"::
        get(Self, socket, Socket),
	bluetalk(Socket, Cmd, Reply),
	( nullreply(Reply)
	 ->  get(Self, label, MyName),
	     bt_areset(Socket),
	     count(reset, MyName),
	     sleep(4),
	     bluetalk(Socket, Cmd, Reply2),
	     ( nullreply(Reply2)
	      -> assert(err(MyName, new_socket)),
		 send(Self, connect),
		 bluetalk(Socket, Cmd, Reply3),
		 ( nullreply(Reply3)
		  -> assert(err(MyName,and(reset,new_socket))),
		     send(Self, slot, reply, 'failure.')
		  ; send(Self, slot, reply, Reply3)
		 )
	      ; send(Self, slot, reply, Reply2)
	     )
	 ; send(Self, slot, reply, Reply)
	).

connect(Self) :->
	"Connect (or re-connect) the Bluetooth channel"::
	get(Self, myname, MyName),
	bt_device(MyName, Addr),
	get(Self, socket, OldSocket),
        ( OldSocket == @nil -> true
	; bt_close(OldSocket),
	  writeln(setting(MyName,socket,@nil)),
	  send(Self, slot, socket, @nil)
	),
	( bt_socket(Addr, BTSocket) ->
	  write(socket(BTSocket)),write(' '),
	  ( BTSocket > -1 ->
	    send(Self, slot, socket, BTSocket),
	    send(Self,colour,colour(darkgreen))
	    ;
	    writeln(returned(MyName,bt_socket,BTSocket)),
	    send(Self,colour,colour(red))
	  )
	  ; writeln(failed(bt_socket(MyName))),
	    send(Self,colour,colour(red))
	).

insertIP(Cmd, IP, Result) :-
        atom_codes(Cmd, Cs),
        atom_codes(IP, ICs),
	[AT] = "@",
        append(Front,[AT|Rest],Cs),
	flatten([Front,ICs,Rest],CommandCs),
	atom_codes(Result,CommandCs).

ip(Self, IP:[name]) :->
	 socket(IP, Socket),
	 send(Self, slot, ipsocket, Socket).

mac_wget(Self, MAC:[name], Cmd:[name]) :->
        getIPfromMAC(MAC,IP),
	send(Self, wget, wget(IP, Cmd)).

wget(Self, IP:[name], Cmd:[name]) :->
        insertIP(Cmd,IP,Command),
	send(Self, slot, wget, Command).

:- pce_end_class. % ebutton

:- pce_begin_class(xcellstat, ebutton).

variable(leak,   int, get, "Leak Detector").

initialise(Self, Label:[name]) :->
	"Initialise the cellstat"::
        send_super(Self, initialise(Label)),
	send_super(Self, slot, level, 85),
	send_super(Self, slot, level_t, 85),
	send_super(Self, slot, levelUnits, '%'),
	get_super(Self, slot, ttemperature, Target),
	get_super(Self, slot, temperature, Temp),
	get_super(Self, slot, tturbidity, ODTarget),
	get_super(Self, slot, turbidity, Turb),

% Default values: Web Interface must work before any updates
        retractall(param(Label,cellstat,_,_)),
	assert(param(Label,cellstat,level,85)),
	assert(param(Label,cellstat,level_t,85)),
	assert(param(Label,cellstat,levelUnits,'%')),
	assert(param(Label,cellstat,ttemperature,Target)),
	assert(param(Label,cellstat,temperature,Temp)),
	assert(param(Label,cellstat,tturbidity,ODTarget)),
	assert(param(Label,cellstat,turbidity,Turb)),
	writeln(cellstat(asserted)).

check_leak(leak(N)) :- !, check_leak_value(N).
check_leak(P)       :-    writeln(expected(leak/1,P)).


check_leak_value(N) :-  N > 700,
			!,
			writeln('No leak'),
			retractall(leak(_)),
			send(@gui?graphicals, for_all,
			     if(message(@arg1,instance_of,spacer),
				message(@arg1,resetColor))).
			

check_leak_value(N) :- N < 300,
		       !,
		       writeln(leak(definitely)),
		       retractall(leak(_)),
		       assert(leak(definite)),
		       send(@gui?graphicals, for_all,
			    if(message(@arg1,instance_of,spacer),
			       message(@arg1,color,red))).

check_leak_value(N) :- writeln(leak(possible,N)),
		       retractall(leak(_)),
		       assert(leak(possible)),
		       send(@gui?graphicals, for_all,
			    if( message(@arg1,instance_of,spacer),
				message(@arg1,color,orange))).

reportDeltaT(Who, Old, New) :-
	DeltaT is integer(abs(Old-New)/10), % DeltaT in degrees
	retractall(err(Who,deltaT(_))),
	(DeltaT > 5 -> assert(err(Who,deltaT(DeltaT))) ; true).

reportTemp(Who, What,Target,Temp) :-  % Temperatures are 10th degrees
	LowThresh is Target - 20, % +- 2 degrees
	HighThresh is Target + 20,
	retractall(temperature(Who,_,_,_)),
	( Temp < LowThresh -> assert(temperature(Who,What,low,Temp))
	; ( Temp > HighThresh -> assert(temperature(Who,What,high,Temp))
	  ; assert(temperature(Who,What,okay,Temp))
	  )
	).

reportTurb(Who,What,Target,Turb) :- 
	LowThresh is Target - 50, % +- .05 units
	HighThresh is Target + 50,
	retractall(turbidity(Who,What,_,_)),
	( Turb < LowThresh -> assert(turbidity(Who,What,low,Turb))
	; ( Turb > HighThresh -> assert(turbidity(Who,What,high,Turb))
	  ; assert(turbidity(Who,What,okay,Turb))
	  )
	).

update(Self) :->
	send_super(Self, update),
        assert(webok).

:- pce_end_class.  % cellstat

:- pce_begin_class(xlagoon, ebutton).

variable(fluorescence,real, get, "Fluorescence").
variable(fluorescence_t, real, get, "Target Fluorescence").
variable(level_max, real, get, "Max Allowed Level").
variable(calibrate_level, real, get, "Calibration Level").

variable(calibration, name, get, "Calibration State Machine").
variable(target_rate, real, get, "Target Flow Rate").
variable(start_time, real, get, "Time since last Calibration state change").
variable(rate_input, real, get, "Calculated Input Flow Rate").
variable(rate_output, real, get, "Calculated Output Flow Rate").
variable(calibration, name, get, "Calibration State Machine").
variable(overflow,   int,   get, "Indication of Overflow").

initialise(Self, Label:[name]) :->
	"Initialise the lagoon"::
        send_super(Self, initialise(Label)),
	send(Self, slot, calibration, normal),
	send_super(Self, slot, level, 30),
	send_super(Self, slot, level_t, 33),
	send(Self, slot, fluorescence_t, 0.2),
	send(Self, slot, overflow, 0),
	send(Self, slot, fluorescence, 0.0),
	retractall(param(Label,lagoon,_,_)),
	assert(param(Label,lagoon,level,33)),
	assert(param(Label,lagoon,level_t,33)),
	assert(param(Label,lagoon,levelUnits,mL)),
	assert(param(Label,lagoon,ttemperature,370)),
	assert(param(Label,lagoon,levelUnits,mL)),
	assert(param(Label,lagoon,temperature,240)).


% update(Self) :-> get_super(Self, socket, @nil),!,fail. % Don't even try

update(Self) :->
        get(Self, slot, myname, MyName),
	writeln(updating(lagoon(MyName))),
        send_super(Self, update),
        send_super(Self,converse,'t'),
        get(Self,slot,reply,Reply),
	(Reply = 'no_connection.'
	-> Label = 'No Bluetooth\nConnection'
	;
	parse_reply(Reply,temperature(Temp),temperature(111)),
        get(Self,slot,temperature,PreviousTemp),
	reportDeltaT(MyName, PreviousTemp, Temp),
        send(Self,slot,temperature,Temp),
        get(Self,slot,ttemperature,Target),
	reportTemp(MyName,lagoon,Target,Temp),
	TempDeg is float(Temp)/10.0,
	TargetDeg is float(Target)/10.0,
	range_color(Target, Temp, Color),
	send(Self, colour(Color)),
        get(Self, slot, level, Level),
        get(Self, slot, level_t, TLevel),
        get(Self, slot, levelUnits, LevelUnits),
        get(Self, slot, fluorescence_t,LuxTarget),
        get(Self, slot, fluorescence,Lux),
	format(atom(GuiTemp), '~4g', [TempDeg]),
	format(atom(GuiTarget), '~4g', [TargetDeg]),
	format(atom(Lux2), '~4g', [Lux]),
%	get(Self,slot,calibration,State),  % Calibration State is the Message
%	send(Self,State),
        concat_atom(['Level ', TLevel, ' / ', Level, LevelUnits, '\n',
	             'Temp  ', GuiTarget, 'C / ',GuiTemp,' C\n',
                     'Lux   ', LuxTarget, ' / ', Lux2, 'lumen' ], Label)
	),
	send(Self, label, Label),
        semaphore(21, webok, update(MyName)),
	NewValues = [
		     param(MyName,lagoon,level_t,TLevel),
		     param(MyName,lagoon,level,Level),
		     param(MyName,lagoon,levelUnits,LevelUnits),
		     param(MyName,lagoon,ttemperature,Target),
		     param(MyName,lagoon,temperature,Temp)],
        retractall(param(MyName,lagoon,_,_)),
	(ground(NewValues)
	 -> maplist(assert,NewValues),
	    write(user_error,updated(MyName,level(Level))),nl(user_error)
	 ;   write(user_error,'  FAILED_update'(MyName)),nl(user_error)
	),
        assert(webok).

	
% Calibration begins after someone sends the 'calibrate' message
% Lagoons can distiguish between input valves and output valves.
% command: do (disable output valves)
%          eo (enable outputs)
%          di (disable input valves)
%          ei (enable input valves)

calibrate(Self) :->
    get(Self,slot,calibration,C),
    writeln(calibration(Self,C)),
    C = normal,
    send(Self,slot,calibration,inflow),
    get_time(Time),
    send(Self,slot,start_time,Time),
    get(Self,slot,level,Level),
    CLevel is 1.1 * Level,
    send(Self,slot,calibrate_level,CLevel).
%    send(Self,command, do).  % Disable Output Flow(s)


setFlux(Self,Level) :->
       send(Self, slot, fluorescence, Level).


normal(_Self) :-> true.

inflow(Self) :->
    get_time(Now),
    get(Self,slot,start_time,STime),
    Now >= STime + 20,
    !,
    writeln(calibrationInflowTimedOut(Self)),
    send(Self,slot,calibration,outflow),
    get(Self,slot,level,Level),
    get(Self,slot,calibrate_level,CLevel),
    Level >= CLevel,
    get_time(Time),
    get(Self,slot,start_time,StartTime),
    RateInput is ( Level/(10*(Time-StartTime))),
    send(Self,slot,rate_input,RateInput),
    CLevel is Level - (Level/11.0),
    get(Self,slot,calibrate_level,Level),
    get(Self,slot,start_time,Time), % Restart timer
%    send(Self,command, eo), % Enable Output Flow(s)
%    send(Self,command, di), % Disable Input Flow(s)
    send(Self,slot,calibration,outflow),
    !.
	       
% Calculate Output Flow Rate with time to decrease volume by 10% (1/11)

outflow(Self) :->
    get_time(Now),
    get(Self,slot,start_time,STime),
    Now >= STime + 20,
    !,
    writeln(calibrationOutflowTimedOut(Self)),
    send(Self,slot,calibration,normal),
    get(Self,slot,level,Level),
    get(Self,slot,calibrate_level,CLevel),
    Level =< CLevel,
    get_time(Time),
    get(Self,slot,start_time,StartTime),
    RateOutput is ( CLevel/(10*(Time-StartTime))),
    send(Self,slot,rate_output,RateOutput),
    send(Self,slot,calibration,normal),
%    send(Self, command, ei), % Re-enable Normal Input Flow(s)
    !.

% Adjust valve times with the calculated Flow Rates
done(Self) :->
    get(Self,slot,target_rate, TargetFlow),
    get(Self,slot,rate_input, RateInput),
    _DeltaInput is TargetFlow - RateInput,
%    send(Self,command,[ai,DeltaInput]),
    get(Self,slot,rate_output, RateOutput),
    _DeltaOutput is TargetFlow - RateOutput,
%    send(Self,command,[ao,DeltaOutput]),
    send(Self,slot,calibration,normal).

:- pce_end_class.  % lagoon


:- pce_begin_class(xsupply, ebutton).

% "Target Level" is used differently in a Supply.  Since we can't
% "maintain" a level in a supply container, but we can alert someone
% when it gets too low.  The Target Level is that level (of depletion).

initialise(Self, Label:[name]) :->
	"Initialise the autosampler"::
        send_super(Self, initialise(Label)),
	send(Self,slot,level,0),
	send(Self,slot,level_t,10),
	send(Self,slot,levelUnits,'L'),
        retractall(param(Label,supply,_,_)),
	assert(param(Label,supply,levelUnits,'L')),
	assert(param(Label,supply,level,0)).

update(Self) :->
	send_super(Self, update),
	get_super(Self, slot, myname, MyName),
	writeln(updating(MyName)),
	get(Self, slot, level, Level),
	get(Self, slot, levelUnits, Units),
	concat_atom([MyName,' \n',Level,Units],Label),
	send(Self, label, Label),
        semaphore(4, webok,update(MyName)),
	 retractall(param(MyName,supply,_,_)),
	 assert(param(MyName,supply,level,Level)),
	 assert(param(MyName,supply,levelUnits,Units)),
        assert(webok),
	get(Self, slot, level_t, Target),
	(Level < Target
	 -> send(Self, colour, colour(red))
         ;  send(Self, colour, colour(black))
        ).
	
:- pce_end_class.  % supply

:- pce_begin_class(xdrainage, ebutton).
initialise(Self, Label:[name]) :->
	"Initialise the drain"::
        send_super(Self, initialise(Label)).

update(_Self) :-> true.
:- pce_end_class.  % drainage


:- pce_begin_class(xsampler, ebutton).

variable(remaining,   int,   get, "Seconds until next Sample").
variable(flowrate,   real,   get, "Flow Rate in Volumes/Hour").

initialise(Self, Label:[name]) :->
	"Initialise the autosampler"::
        send_super(Self, initialise(Label)),
	assert(param(Label,sampler,flowrate,3.5)),
	send(Self, slot, flowrate, 3.5),
	send(Self, slot, myname, Label),
	send(Self,slot,remaining,3600).

update(Self) :->
	send_super(Self, update),
	( get_super(Self, socket, @nil) -> true
	; send_super(Self,converse,'t'),
	  get_super(Self, reply, Reply),
	  DefaultTime is 99*60, % 99 Minutes
	  parse_reply(Reply, Remaining, remaining(DefaultTime)),
	  Remaining = remaining(Time),
	  send(Self,slot,remaining,Time)
	),
	send(Self,fast_update).
	  
fast_update(Self) :->
	get_super(Self, slot, myname, MyName),
	get(Self,slot,remaining,Time),
	Hours is floor(Time/3600),
	Minutes is floor(mod(Time,3600)/60),
	Seconds is Time mod 60,
	timeatom(Hours,Minutes,Seconds,TimeAtom),
	timer_left(CTime),
	param(updateCycle(Cycle)),
	TimeLeft is Cycle-CTime,
	(TimeLeft < 0 -> ShowTime = Cycle ; ShowTime = TimeLeft),
	(ShowTime < 10
	-> concat_atom(['\nAutoSampler\n',
		      ' Level reading in Progress...\n',
		      TimeAtom,' to next sample\n'],Label)
	; concat_atom(['\nAutoSampler\n',
		      ShowTime,' seconds to level reading\n',
		      TimeAtom,' to next sample\n'],Label)
        ),
	send(Self, label, Label),
        semaphore(19,webok,update(MyName)),
	( param(MyName,sampler,flowrate,FlowRate) -> true
	; write(user_error,'THAT WAS CERTAINLY THE PROBLEM'),nl(user_error)
	),
	NewValues = [param(MyName,sampler,flowrate,FlowRate),
		     param(MyName,sampler,timeleft,ShowTime),
		     param(MyName,sampler,nextsample,TimeAtom)],
	(ground(NewValues) ->
             retractall(param(MyName,sampler,_,_)),
	     maplist(assert,NewValues),
             write(user_error,' t'(ShowTime))
	 ;   write(user_error,'   FAILED_update'(MyName)),nl(user_error)
	),
        assert(webok).

flow(Self, Rate:[real]) :-> 
	send(Self, slot, flowrate, Rate),
	get(Self,slot,myname, MyName),
	retractall(param(MyName,sampler,flowrate,_)),
	assert(param(MyName, sampler,flowrate,Rate)).

:- pce_end_class.  % autosampler


:- pce_begin_class(spacer, box).

variable(defaultColor, name, get, "DefaultColor" ).

initialise(Self, _Name:[name]) :->
        screen(DW,_,WW,_,_),
	NWid is DW*WW/110,
        send_super(Self, initialise(NWid, 6)),
	send(Self, colour, colour(black)),
	send(Self, slot, defaultColor, black),
	send(Self, fill_pattern, colour(black)).

color(Self, Color) :->
     ( get(Self,slot,defaultColor,colour(black))   % First time
      -> send(Self,slot,defaultColor,Color)  % New default
      ; true
     ),
     send(Self, colour, colour(Color)),
     send(Self, fill_pattern, colour(Color)).

resetColor(Self) :-> 
     get(Self,slot,defaultColor,C),
     send(Self, colour, colour(C)).

update(_Self) :-> true.

:- pce_end_class.

:- pce_begin_class(hotbox, box).
initialise(Self, Color:[name]) :->
        "Initialise"::
        window_percent(1,2,Width,Height),
        send_super(Self, initialise(Width,Height)),
	send(Self, colour, colour(black)),
        send(Self, fill_pattern, colour(Color)).
:- pce_end_class.
