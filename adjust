:- use_module(library(time)).
:- use_module(newpid).
% The PID algorithm will call get_input/2 and set_output/3,
% but their implementation is PID independent, so they live here.

% 
% Maintaining a given flow rate must be possible with
% input and output valve timings between these limits.
%
% This could end up being an empirically derived table,
% but we will try a simple mathematical model because
% we only need min/max limits on valve timings, not
% a precise relationship with flow rates.
% 
% 1) Lagoons be very different from the Cellstat.
% 2) Input/Output valve cycle schedules can be different.
%
% Eg. Lagoon input time is in ms every 30 seconds
%     Lagoon output time is in ms every 90 seconds
%     Cellstat input time is in ms every 20 seconds
%     Cellstat output time is in ms every 90 seconds
%

:- dynamic dynamicFlowRateTable/5.
:- multifile dynamicFlowRateTable/5.

%
% (r1, r2, lx, ly)   (upper, lower reticule, readingX, readingY)
% (94, 109, 250, 121)
% reticuleCenterSU = ( r1+r2 )/2
% reticuleVolumeSU = ( r2 - r1 )
%
% scaleToSU     =   (reticuleVolumeSU / reticuleVolumePC)
% scaleToPC     =   (reticuleVolumePC / reticuleVolumeSU)
% 
% reticuleVolumePC   =   10
% targetVolumePC = 30     
% targetVolumeSU =  targetVolumePC * (reticuleVolumeSU/reticuleVolumePC)
% zeroLevelSU    =  reticuleCenterSU + targetVolumePC * (reticuleVolumeSU/reticuleVolumePC)
%
% inputValuePC  = ( zeroLevelSU - inputLevelSU )* scaleToPC
% 
% TEST: TARGET = ( center + TARGET * rvsu/rvpc - center) * (rcpc/rvsu)
% 
% fullVolumeSU   = 100 * (reticuleVolumeSU/reticuleVolumePC)
% zeroLelelSU    = reticuleCenterSU + targetVolumeSU

:- dynamic host/4, lagoon/4.

current_level(lagoon, Num, Level) :-
        lagoon(R1, R2, _X, LY),
	param(lagoonReticuleVolumemL(Num, RVmL)),
	param(lagoonTargetVolumemL(Num, TVmL)),
	param(lagoonReticuleVolumePC(Num,RVPC)),
	current_level(R1,R2,LY,RVmL,TVmL,RVPC, Level).

current_level(host, 0, Level) :-
        host(R1,R2,_X, LY),
	param(hostReticuleVolumemL(RVmL)),
	param(hostTargetVolumemL(TVmL)),
	param(hostReticuleVolumePC(RVPC)),
	current_level(R1,R2,LY,RVmL,TVmL,RVPC, Level).

current_level(R1,R2,Y, RVmL, TVmL, RVPC, LevelPC) :-
	ReticuleCenterSU is ( R1+R2 )/2,
	ReticuleVolumeSU =  R2 - R1,
%	ScaleToSU  is  ReticuleVolumeSU / RVPC,
	ScaleToPC  is  RVPC / ReticuleVolumeSU,
	ZeroLevelSU is ReticuleCenterSU + (TVmL * (ReticuleVolumeSU / RVmL)),
	LevelPC is  (ZeroLevelSU - Y) * ScaleToPC.
	
get_error(Name, Error) :-
        dblog(pid,get_error(Name)),
        atom_codes(Name,NCodes),
	append(FCodes,[NC],NCodes),
	atom_codes( Functor, FCodes ),
	( number_codes( N, [NC]) ->
	  Query =.. [Functor,N,Error],
	  dblog(pid,calling(Query)),
	  ( call(Query) -> true ; dblog(pid,failed(Query)) ),
	  dblog(pid,called(Query))
	  ; dblog(pid,error(component_name,no_digit,Name))
	).

showFlowRateTable :-
        timestring(TimeStamp),
	flog(TimeStamp),
        flog('FLOW RATE TABLE'),
        flowRateTable(What,Dir,Rate,Min,Max),
        Term =.. [What,Dir,Rate,Min,Max],
        flog(Term),
        fail.
showFlowRateTable :- flog(tableDone).

% Assert can override Min/Max flow rate table for any component.

chkFlowRateTable(Type,Dir,Rate,Min,Max) :-
      flowRateTable(Type,Dir,Rate,Min,Max),!.

flowRateTable(Type,Dir,Rate,Min,Max) :-
          dynamicFlowRateTable(Type,Dir,Rate,Min,Max).

flowRateTable(Type,Dir,Rate,Min,Max) :-
          member(Type,[lagoon,cellstat]),				    
          component(_,Type,Obj),
	  get(Obj,tf,Rate),
          sFlowRateTable(Type,Dir,Rate,Min,Max).

sFlowRateTable(lagoon,in, Rate,MinVin,MaxVin) :-
          MinVin is integer(Rate * 100),
          MaxVin is integer(Rate * 2000).
sFlowRateTable(lagoon,out, Rate,MinVout,MaxVout) :-
          MinVout is integer(Rate * 100),
          MaxVout is integer(Rate * 2000).
sFlowRateTable(cellstat,in,Rate,MinVin,MaxVin) :-
          MinVin is integer(Rate * 100),
          MaxVin is integer(Rate * 2000).
sFlowRateTable(cellstat,out, Rate,MinVout,MaxVout) :-
          MinVout is 0,  % Lagoons might consume all host cells
          MaxVout is integer(Rate * 2000).

inTimeRange(Obj, Val, Dir, NewVal) :-
     component(_,Type,Obj),
     get(Obj,tf,Rate),
     chkFlowRateTable(Type,Dir,Rate,Min,Max),
     compare_minmax(Op, Val, Min, Max),
     constrain(Op, Val, Min, Max, NewVal).

initPID :-
	pid_controllers(Cs),
	launch_controllers(Cs).

get_input(Name, l, Value) :-
	get_error(Name, Value), fail.
get_input(Name, Var, Value) :-
        dblog(pid,webValue(Name,Var)),
	webValue(@Name, Var, Value).

%
% set_output(Component, Var, Old, New)
%
% For liquid level control, level readings
% result in incremental changes in valve open times.
% Level too high: -inflow  +outflow 
%       too low:  +inflow  -outflow
%
% The Autosampler controls drain valves for the other components
% Lagoon name ends with <digit>: v<digit> is that lagoon's drain
% Otherwise it must be the Cellstat's drain 'v0'
%

set_output(Name, Var, Old, New) :-
     ( component(Name,cellstat,_)
     -> Inflow is integer(50*(New-Old)) % 1000 mL vessel
     ;  Inflow is integer(5*(New-Old))  %  100 mL (smaller)
     ),
     adjust(Var,@Name,Inflow).

% Different for levels (in and out valves)
%       or temperature (heater on/off)

adjust(l,Obj,Value) :-
	dblog(pid,adjust_level(Obj,Value)),
	adjust_level(Obj,Value),
	dblog(pid,adjusted(Value)).
adjust(t,@Name,NYI) :-
	dblog(pid, adjust_nyi(Name,temperature,NYI)).

% Adjust level is two calls to adjust_valve (in and out)
adjust_level(Obj, Inflow) :-
     Obj = @Name,		  
     component_valves(Name,InValve,OutName,OutValve),
     adjust_valve(Obj,Obj,InValve,Inflow, in),
     flog(after(adjust_valve1)),
     assert(changed(Obj,InValve,Inflow)),
     component(OutName,_,VObj),
     Outflow is -Inflow,
     adjust_valve(Obj,VObj,OutValve,Outflow, out),
     flog(after(adjust_valve2)),
     assert(changed(VObj,OutValve,Outflow)).

adjust_valve(Obj, ValveObj, Valve, Amt, Dir) :-
      @Name = Obj,
      @VName = ValveObj,
      flog(adjusting(Name,VName,Valve,Amt,Dir)),
      get(ValveObj, Valve, Setting),
      New is Setting + Amt,
      flog(check_range(Name,VName,Valve,Dir,New)),
      inTimeRange(Obj, New, Dir, Actual),
      flog(sending(VName, Valve,Actual)),
      send(ValveObj, Valve, Actual),
      flog(sent),
      flog(adjusted(Name,VName,Valve,old(Setting),delta(Amt),new(New),actual(Actual))).
