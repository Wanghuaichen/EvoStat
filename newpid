:- module( pid, [ launch_controllers/1,
		  pidstart/0,
		  pidstop/0,
		  compute/0    ]).
:- use_module(library(apply)).
:- dynamic stop_controllers/0, iterm/4, state/8.
%
% Proportional/Integral/Differential (PID) control
% state machine via assert/retract of iterm/4, state/8.
%

pidstop  :- assert(stop_controllers).

pidstart :-
	thread_create(control, _, []),
	writeln('PID controllers started').

launch_controllers(List) :-
	maplist(controller, List),
	pidstart.

% Info updated whenever compute is called:
% iterm( Id, IntegralTerm, LastInput, LastCycleTime )
%
% Per-controller information in:
% state( Id, Kp, Ki, Kd, SetPoint, Min, Max, SampleTime)

% Time to next compute cycle for each controller
next_interval(Interval) :-
	get_time(Now),
	iterm(Id, _, _, LastTime),
	state(Id,_,_,_,_,_,_,DeltaT),
        Time is DeltaT - (Now - LastTime),
	limit(Time, 0, DeltaT, Interval).

% Create PID controller from:
% pid(Name, Kp, Ki, Kd, SetPt, Min, Max, DeltaT)
% pid(lagoon,0.4,0.2,0.2, 30,   10, 100,  30 )

% sanity check: pid/9 specification subject to change.
controller(PID) :-
	\+ functor(PID,pid,8),
	!,
	writeln(error(pid_spec,PID)).

controller(pid(Id,Kp,Ki,Kd,SetPt,Min,Max,DeltaT)) :-
	get_time(Last),
	LastTime is Last - 1,
	retractall(iterm(Id,_,_,_)),
	assert(iterm(Id, SetPt, SetPt, LastTime)),
	retractall(state(Id,_,_,_,_,_,_,_)),
	assert(state(Id,Kp,Ki,Kd,SetPt,Min,Max,DeltaT)).

control :-
	iterm(_, _, _, _), % requires an active controller
	retractall(stop_controllers),
	repeat,
		setof(T,next_interval(T), [Interval|_]), % Shortest time
		sleep(Interval),
		compute,        % Run one cycle
	stop_controllers,       % Signal to stop
	writeln('      Stopping PID Controllers').

compute :-
	iterm(Id, ITerm0, LastInput, LastTime),
	get_time(Now),
	Elapsed is Now - LastTime,
	state(Id, Kp,Ki,Kd, SetPoint, Min, Max, SampleTime),
	Elapsed > SampleTime,
	get_input(Id, Input),            % Get current value
	Error is SetPoint - Input,       % Calculate  Error
	Integral is ITerm0 + Ki * Error, % New Integral Term
	limit(Integral,Min,Max,ITerm),   % Keep within bounds
	PID is Kp*Error + ITerm - Kd*(Input-LastInput),
	limit(PID, Min, Max, Output),    % Keep within bounds
	retractall(iterm(Id,_,_,_)),
	assert(iterm(Id,ITerm,Input,Now)),
	( in_deadzone(SetPoint, Output) -> write('.'),flush_output
        ; set_output(Id, Input, Output)
	).

in_deadzone(V1,V2) :- deadzone(D), N is abs(V1-V2), N<D.

% limit(In, MinValue, MaxValue, Out).

limit(X, Min,   _, Min) :- X < Min, !.
limit(X,   _, Max, Max) :- X > Max, !.
limit(X,   _,   _,   X).



