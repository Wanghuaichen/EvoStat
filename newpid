%
% Proportional/Integral/Differential (PID) control requires state
% which Prolog gets with assert/retract of facts iterm/4, state/8.
%
:- module( pid, [ launch_controllers/1, pidstart/0, pidstop/0, compute/0 ]).
:- use_module(library(apply)).

:- dynamic stop_controllers/0, iterm/4, state/8.

pidstop  :- assert(stop_controllers).
pidstart :- thread_create(control, _, []), writeln('Started PID controllers').

launch_controllers(List) :-
	maplist(controller, List),
	pidstart.

% iterm( Id, ITerm, LastInput, LastTime )
% iterm/4 holds the Integral term, Last input, and Last Sample time
% the state information which must be updated when compute/3 is called.

% state( Id, Kp, Ki, Kd, SetPt, Min, Max, SampleTime)
% state( Id, Kp, Ki, Kd, SetPoint, Min, Max, SampleTime)
% state/9 contains all of the other constants of operation

% Generate time to next compute cycle for every controller
next_interval(Interval) :-
	get_time(Now),
	iterm(Id, _, _, LastTime),
	state(Id,_,_,_,_,_,_,DeltaT),
        Time is DeltaT - (Now - LastTime),
	limit(Time, 1, DeltaT, Interval).

%
% create a PID controller
% Example: pid(Name, 0.4, 0.2, 0.2, 30,   30,  10, 100,     30     )
controller(pid(Id,   Kp,  Ki,  Kd, SetPt, Out, Min, Max, SampleTime)) :-
	limit(Out, Min, Max, ITerm),
	get_time(Last),
	LastTime is Last - 1,
	retractall(iterm(Id,_,_,_)),
	assert(iterm(Id, ITerm, SetPt,LastTime)),
	retractall(state(Id,_,_,_,_,_,_,_)),
	assert(state(Id,Kp,Ki,Kd,SetPt,Min,Max,SampleTime)).

control :-
	iterm(_, _, _, _),            % requires at least one active controller
	retractall(stop_controllers),
	repeat,
		setof(T,next_interval(T), [Interval|_]),
		writeln(sleeping(Interval)),
		sleep(Interval),
		compute,        % Run a cycle on each controller that's due
	stop_controllers,       % True if PID is being stopped
	writeln('               Stopping PID Controllers').

compute :-
	iterm(Id, ITerm0, LastInput, LastTime),
	get_time(Now),
	Elapsed is Now - LastTime,
	state(Id, Kp,Ki,Kd, SetPoint, Min, Max, SampleTime),
	Elapsed > SampleTime,

	get_input(Id, Input),         % Read the current value
	Error is SetPoint - Input,
	Integral is ITerm0 + Ki * Error,
	limit(Integral,Min,Max,ITerm),   % Keep within boupnds
	PID is Kp*Error + Integral - Kd*(Input-LastInput),
	limit(PID, Min, Max, Output),    % Keep within bounds
	retractall(iterm(Id,_,_,_)),
	assert(iterm(Id,ITerm,Input,Now)),
	writeln(done(Id)),
	set_output(Id, Input, Output).


limit(X,Min,_,Min) :- X < Min, !.
limit(X,_,Max,Max) :- X > Max, !.
limit(X,_,  _,  X).



